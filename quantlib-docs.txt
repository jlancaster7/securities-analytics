Basics
Below are the commands to set up the Quant Lib with evaluation date. Everything starts with “evaluation date” which means the date you want to value a instrument. Consider you want to value a “Swap” as of 09/16/2020, you will first set the evaluationDate in QuantLib. Underhood C++ quant library is packaged using SWIg and python is more a API calling the C++ library.

Settings

#import the Quant Lib
import QuantLib as ql

# Let the today date whenwe want to value a instrument be
today = ql.Date(15,6,2020)

# we can set evaluationDate in QL as
ql.Settings.instance().evaluationDate = today
print(ql.Settings.instance().evaluationDate);
# prints..June 15th, 2020

# or you can do
today = ql.Date(15,12,2021);
ql.Settings.instance().setEvaluationDate(today)
print(ql.Settings.instance().evaluationDate)
# prints..December 15th, 2021
Moves date of referenced curves: Following returns the term structure based on FlatForward

settlementDays = 2

# Holiday calendar of united states
calendar = ql.UnitedStates()

forwardRate = 0.05

"""Day Counter provides methods for determining the length of a time period according to given market convention,
both as a number of days and as a year fraction."""
dayCounter = ql.Actual360()

# Construct flat forward rate term structure
flatForwardTermStructure = ql.FlatForward(settlementDays, calendar, forwardRate, dayCounter)

flatForwardTermStructure.referenceDate()

print("Max Date: ", flatForwardTermStructure.maxDate())
Changes evaluation date of calculation: Following shows the use of evaluation or Valuation date. Lets construct a schedule which will be used to create a leg and then we will calculate interest rate on the leg.

today = ql.Date(15,6,2020)
ql.Settings.instance().evaluationDate = today

effectiveDate = ql.Date(15, 6, 2020)
terminationDate = ql.Date(15, 6, 2022)
Create a schedule

schedule = ql.MakeSchedule(effectiveDate, terminationDate, ql.Period('6M'))
create a fixed rate leg using helper class building a sequence of fixed rate coupons

notional = [100.0]
rate = [0.05]
leg = ql.FixedRateLeg(schedule, dayCounter, notional, rate)
Interest rate class encapsulate the interest rate compounding algebra. It manages day-counting conventions, compounding conventions, conversion between different conventions, discount/compound factor calculations, and implied/equivalent rate calculations.

dayCounter = ql.Thirty360()
rate = 0.03

"""
ql/Compounding.hpp
    //! Interest rate compounding rule
    enum Compounding { Simple = 0,          //!< \f$ 1+rt \f$
                       Compounded = 1,      //!< \f$ (1+r)^t \f$
                       Continuous = 2,      //!< \f$ e^{rt} \f$
                       SimpleThenCompounded, //!< Simple up to the first period then Compounded
                       CompoundedThenSimple //!< Compounded up to the first period then Simple
    };
"""

compoundingType = ql.Compounded

"""
ql/time/frequency.hpp
enum Frequency { NoFrequency = -1,     //!< null frequency
                     Once = 0,             //!< only once, e.g., a zero-coupon
                     Annual = 1,           //!< once a year
                     Semiannual = 2,       //!< twice a year
                     EveryFourthMonth = 3, //!< every fourth month
                     Quarterly = 4,        //!< every third month
                     Bimonthly = 6,        //!< every second month
                     Monthly = 12,         //!< once a month
                     EveryFourthWeek = 13, //!< every fourth week
                     Biweekly = 26,        //!< every second week
                     Weekly = 52,          //!< once a week
                     Daily = 365,          //!< once a day
                     OtherFrequency = 999  //!< some other unknown frequency
    };
"""

frequency = ql.Annual
interestRate = ql.InterestRate(rate, dayCounter, compoundingType, frequency)
4.958531764309427

ql/cashflows/Cashflows.hpp The NPV is the sum of the cash flows, each discounted according to the given constant interest rate. The result is affected by the choice of the interest-rate compounding and the relative frequency and day counter.

ql.Settings.instance().evaluationDate = ql.Date(15,12,2020)
print( ql.CashFlows.npv(leg, rate, False) )
2.4906934531375144

Array
creates an empty array

ql.Array()
creates the array and fills it with value

ql.Array(size, value)
creates the array and fills it according to a0=value,ai=ai−1+increment

ql.Array(size, value, increment)
Matrix
creates a null matrix

ql.Matrix()
creates a matrix with the given dimensions

ql.Matrix(rows, columns)
creates the matrix and fills it with value

ql.Matrix(rows, columns, value)
ql.Matrix()
ql.Matrix(2,2)
ql.Matrix(2,2,0.5)
A = ql.Matrix(3,3)
A[0][0]=0.2
A[0][1]=8.4
A[0][2]=1.5
A[1][0]=0.6
A[1][1]=1.4
A[1][2]=7.3
A[2][0]=0.8
A[2][1]=4.4
A[2][2]=3.2
Observable
import QuantLib as ql

flag = None
def raiseFlag():
    global flag
    flag = 1

me = ql.SimpleQuote(0.0)
obs = ql.Observer(raiseFlag)
obs.registerWith(me)
me.setValue(3.14)
if not flag:
    print("Case 1: Observer was not notified of market element change")
flag = None
obs.unregisterWith(me)
me.setValue(3.14)
if not flag:
    print("Case 2: Observer was not notified of market element change")
Quotes
SimpleQuote
ql.SimpleQuote(value)
s = ql.SimpleQuote(0.01)
Functions

value

setValue

isValid

s.value()
s.setValue(0.05)
s.isValid()
DerivedQuote
ql.DerivedQuote(quoteHandle, function)
d1 = ql.SimpleQuote(0.06)
d2 = ql.DerivedQuote(ql.QuoteHandle(d1),lambda x: 10*x)
CompositeQuote
ql.CompositeQuote(quoteHandle, quoteHandle, function)
c1 = ql.SimpleQuote(0.02)
c2 = ql.SimpleQuote(0.03)

def f(x,y):
    return x+y

c3 = ql.CompositeQuote(ql.QuoteHandle(c1),ql.QuoteHandle(c2), f)
c3.value()

c4 = ql.CompositeQuote(ql.QuoteHandle(c1),ql.QuoteHandle(c2), lambda x,y:x+y)
c4.value()
DeltaVolQuote
A class for FX-style quotes where delta-maturity pairs are quoted in implied vol

ql.DeltaVolQuote(delta, volQuoteHandle, maturity, deltaType)
ql.DeltaVolQuote(volQuoteHandle, deltaType, maturity, atmType)
deltaType = ql.DeltaVolQuote.Fwd    # Also supports: Spot, PaSpot, PaFwd
atmType = ql.DeltaVolQuote.AtmFwd   # Also supports: AtmSpot, AtmDeltaNeutral, AtmVegaMax, AtmGammaMax, AtmPutCall50

maturity = 1.0
volAtm, vol25DeltaCall, vol25DeltaPut = 0.08, 0.075, 0.095

atmDeltaQuote = ql.DeltaVolQuote(ql.QuoteHandle(ql.SimpleQuote(volAtm)), deltaType, maturity, atmType)
vol25DeltaPutQuote = ql.DeltaVolQuote(-0.25, ql.QuoteHandle(ql.SimpleQuote(vol25DeltaPut)), maturity, deltaType)
vol25DeltaCallQuote = ql.DeltaVolQuote(0.25, ql.QuoteHandle(ql.SimpleQuote(vol25DeltaCall)), maturity, deltaType)



Bonds
Bond
Redemptions and maturity are calculated from the coupon data, if available. Therefore, redemptions must not be included in the passed cash flows.

classql.Bond(settlementDays, calendar, issueDate, coupons)
start = ql.Date(15,12,2019)
maturity = ql.Date(15,12,2020)
schedule = ql.MakeSchedule(start, maturity, ql.Period('6M'))

interest = ql.FixedRateLeg(schedule, ql.Actual360(), [100.], [0.05])
bond = ql.Bond(0, ql.TARGET(), start, interest)
.bondYield(dayCounter, compounding, frequency, accuracy=1.0e-8, maxEvaluations=100)
.bondYield(cleanPrice, dayCounter, compounding, frequency, settlementDate=Date, accuracy=1.0e-8, maxEvaluations=100)
bond.bondYield(100, ql.Actual360(), ql.Compounded, ql.Annual)
.dirtyPrice()
bond.dirtyPrice()
.dirtyPrice(yield, dayCount, compounding, frequency)
bond.dirtyPrice(0.05, ql.Actual360(), ql.Compounded, ql.Annual)
ZeroCouponBond
ql.ZeroCouponBond(settlementDays, calendar, faceAmount, maturityDate)
bond = ql.ZeroCouponBond(2, ql.TARGET(), 100, ql.Date(20,6,2020))
FixedRateBond
ql.FixedRateBond(settlementDays, calendar, faceAmount, startDate, maturityDate, tenor, coupon, paymentConvention)
ql.FixedRateBond(settlementDays, faceAmount, schedule, coupon, paymentConvention)
bond = ql.FixedRateBond(2, ql.TARGET(), 100.0, ql.Date(15,12,2019), ql.Date(15,12,2024), ql.Period('1Y'), [0.05], ql.ActualActual(ql.ActualActual.Bond))
AmortizingFixedRateBond
ql.AmortizingFixedRateBond(settlementDays, notionals, schedule, coupons, accrualDayCounter, paymentConvention=Following, issueDate=Date())
notionals = [100,100,100,50]
schedule = ql.MakeSchedule(ql.Date(25,1,2018), ql.Date(25,1,2022), ql.Period('1y'))
bond = ql.AmortizingFixedRateBond(0, notionals, schedule, [0.03], ql.Thirty360(ql.Thirty360.USA))
FloatingRateBond
ql.FloatingRateBond(settlementDays, faceAmount, schedule, index, dayCounter, paymentConvention)
schedule = ql.MakeSchedule(ql.Date(15,6,2020), ql.Date(15,6,2022), ql.Period('6m'))
index = ql.Euribor6M()
bond = ql.FloatingRateBond(2,100, schedule, index, ql.Actual360(), spreads=[0.01])
AmortizingFloatingRateBond
ql.FloatingRateBond(settlementDays, notionals, schedule, index, dayCounter)
notional = [100, 50]
schedule = ql.MakeSchedule(ql.Date(15,6,2020), ql.Date(15,6,2022), ql.Period('1Y'))
index = ql.Euribor6M()
bond = ql.AmortizingFloatingRateBond(2, notional, schedule, index, ql.ActualActual(ql.ActualActual.Bond))
CMS Rate Bond
ql.CmsRateBond(settlementDays, faceAmount, schedule, index, dayCounter, paymentConvention, fixingDays, gearings, spreads, caps, floors)
schedule = ql.MakeSchedule(ql.Date(15,6,2020), ql.Date(15,6,2022), ql.Period('1Y'))
index = ql.EuriborSwapIsdaFixA(ql.Period('10y'))
bond = ql.CmsRateBond(2, 100, schedule, index, ql.Actual360(), ql.ModifiedFollowing, fixingDays=2, gearings=[1], spreads=[0], caps=[], floors=[])
Callable Bond
ql.CallableFixedRateBond(settlementDays, faceAmount, schedule, coupons, accrualDayCounter, paymentConvention, redemption, issueDate, putCallSchedule)
schedule = ql.MakeSchedule(ql.Date(15,6,2020), ql.Date(15,6,2022), ql.Period('1Y'))
putCallSchedule = ql.CallabilitySchedule()

my_price  = ql.BondPrice(100, ql.BondPrice.Clean)

putCallSchedule.append(
    ql.Callability(my_price, ql.Callability.Call, ql.Date(15,6,2021))
)

bond = ql.CallableFixedRateBond(2, 100, schedule, [0.01], ql.Actual360(), ql.ModifiedFollowing, 100, ql.Date(15,6,2020), putCallSchedule)
Convertible Bond
BondFunctions
bond = ql.FixedRateBond(
    2, ql.TARGET(), 100.0,
    ql.Date(15,12,2019), ql.Date(15,12,2024), ql.Period('1Y'),
    [0.05], ql.ActualActual(ql.ActualActual.Bond))
Date Inspectors

ql.BondFunctions.startDate(bond)
ql.BondFunctions.maturityDate(bond)
ql.BondFunctions.isTradable(bond)
Cashflow Inspectors

ql.BondFunctions.previousCashFlowDate(bond)
ql.BondFunctions.previousCashFlowDate(bond, ql.Date(15,12,2020))
ql.BondFunctions.previousCashFlowAmount(bond)
ql.BondFunctions.previousCashFlowAmount(bond, ql.Date(15,12,2020))
ql.BondFunctions.nextCashFlowDate(bond)
ql.BondFunctions.nextCashFlowDate(bond, ql.Date(15,12,2020))
ql.BondFunctions.nextCashFlowAmount(bond)
ql.BondFunctions.nextCashFlowAmount(bond, ql.Date(15,12,2020))
Coupon Inspectors

ql.BondFunctions.previousCouponRate(bond)
ql.BondFunctions.nextCouponRate(bond)
ql.BondFunctions.accrualStartDate(bond)
ql.BondFunctions.accrualEndDate(bond)
ql.BondFunctions.accrualPeriod(bond)
ql.BondFunctions.accrualDays(bond)
ql.BondFunctions.accruedPeriod(bond)
ql.BondFunctions.accruedDays(bond)
ql.BondFunctions.accruedAmount(bond)
YieldTermStructure

crv = ql.FlatForward(2, ql.TARGET(), 0.04, ql.Actual360())
ql.BondFunctions.cleanPrice(bond, crv)
ql.BondFunctions.bps(bond, crv)
ql.BondFunctions.atmRate(bond, crv)
Yield (a.k.a. Internal Rate of Return, i.e. IRR) functions

rate = ql.InterestRate(0.05, ql.Actual360(), ql.Compounded, ql.Annual)
ql.BondFunctions.cleanPrice(bond, rate)
ql.BondFunctions.bps(bond, rate)
ql.BondFunctions.duration(bond, rate)
ql.BondFunctions.convexity(bond, rate)
ql.BondFunctions.basisPointValue(bond, rate)
ql.BondFunctions.yieldValueBasisPoint(bond, rate)
Z-spread functions

crv = ql.FlatForward(2, ql.TARGET(), 0.04, ql.Actual360())
ql.BondFunctions.zSpread(bond, 101, crv, ql.Actual360(), ql.Compounded, ql.Annual)


Indexes
Interest Rate
IborIndex
ql.IborIndex(familyName, tenor, settlementDays, currency, fixingCalendar, convention, endOfMonth, dayCounter, =Handleql.YieldTermStructure())
ql.IborIndex('MyIndex', ql.Period('6m'), 2, ql.EURCurrency(), ql.TARGET(), ql.ModifiedFollowing, True, ql.Actual360())
ql.Libor('MyIndex', ql.Period('6M'), 2, ql.USDCurrency(), ql.TARGET(), ql.Actual360())
ql.Euribor(ql.Period('6M'))
ql.USDLibor(ql.Period('6M'))
ql.Euribor6M()
Derived Classes:

ql.Euribor()

Constructors for derived classes:

ql.Euribor(period)
ql.Euribor(period, yts)
OvernightIndex
ql.OvernightIndex(name, fixingDays, currency, calendar, dayCounter, =ql.YieldTermStructureHandle())
name = 'CNYRepo7D'
fixingDays = 1
currency = ql.CNYCurrency()
calendar = ql.China()
dayCounter = ql.Actual365Fixed()
overnight_index = ql.OvernightIndex(name, fixingDays, currency, calendar, dayCounter)
SwapIndex
ql.SwapIndex(familyName, tenor, settlementDays, currency, fixingCalendar, fixedLegTenor, convention, dayCounter, index, =Handleql.YieldTermStructure())
Derived Classes:

ql.ChfLiborSwapIsdaFix

ql.EuriborSwapIsdaFixA

ql.EuriborSwapIsdaFixB

ql.EuriborSwapIfrFix

ql.EurLiborSwapIfrFix

ql.EurLiborSwapIsdaFixA

ql.EurLiborSwapIsdaFixB

ql.GbpLiborSwapIsdaFix

ql.JpyLiborSwapIsdaFixAm

ql.JpyLiborSwapIsdaFixPm

ql.OvernightIndexedSwapIndex

ql.UsdLiborSwapIsdaFixAm

ql.UsdLiborSwapIsdaFixPm

Constructors for derived classes:

ql.EuriborSwapIsdaFixA(period)
ql.EuriborSwapIsdaFixA(period, yts)
ql.EuriborSwapIsdaFixA(period, forward_yts, discounting_yts)
SwapSpreadIndex
SwapSpreadIndex(familyName, swapIndex1, swapIndex2, gearing1=1.0, gearing2=-1.0)
Inflation
Zero Inflation
ql.{InflationIndex}(interpolated=bool)
ql.{InflationIndex}(bool, ZeroInflationTermStructure)
ql.UKRPI

ql.USCPI

ql.EUHICP

ql.EUHICPXT

YoY inflation
ql.YYEUHICP

ql.YYEUHICPXT

ql.YYFRHICP

ql.YYUKRPI

ql.YYUSCPI

ql.YYZACPI

Fixings
fixingDates = [cf.fixingDate() for cf in map(ql.as_floating_rate_coupon, loan)]
euribor3m.clearFixings()

euribor3m.addFixing(ql.Date(17, 7, 2018), -0.3)
euribor3m.addFixings([ql.Date(12, 7, 2018), ql.Date(13, 7, 2018)], [-0.3, -0.3])
[dt for dt in index.timeSeries().dates()]
[dt for dt in index.timeSeries().values()]
To get the fixing dates form an instrument:

swap3 = ql.MakeVanillaSwap(ql.Period('3y'), ql.Euribor6M(), 0.01, ql.Period("-2D"))
fixingDates = [cf.fixingDate() for cf in map(ql.as_floating_rate_coupon, swap3.floatingLeg())]
Indexes have calendars and will not accept invalid fixing dates:

index.isValidFixingDate(ql.Date(25,12,2019))
c = index.fixingCalendar()
c.name()
IndexManager
ql.IndexManager.instance().histories()

for dt, value in zip(im.getHistory('EURIBOR6M ACTUAL/360').dates(),im.getHistory('EURIBOR6M ACTUAL/360').values()):
    print(dt, value)


IndexManager.instance().clearHistory(index.name())
